#!/usr/bin/env python3
"""
Classify a single binary using trained GAT v2 model
Usage: python classify_binary.py <binary_path>
"""

import os
import sys
import json
import torch
import tempfile
from pathlib import Path

from model import GATv2APTClassifier
from dataset import load_label_mapping
from extract_features import extract_features_from_binary, initialize_pyghidra, initialize_embedding_model
from torch_geometric.data import Data

# =============================================================================
# Configuration
# =============================================================================
MODEL_DIR = Path("models")
LABEL_MAPPING_PATH = MODEL_DIR / "label_mapping.json"
BEST_MODEL_PATH = MODEL_DIR / "best_model.pth"

DEVICE = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

# =============================================================================
# Classification Functions
# =============================================================================

def load_graph_from_json(json_path):
    """
    Load graph from JSON file and convert to PyTorch Geometric Data object

    Args:
        json_path: Path to JSON file

    Returns:
        Data: PyTorch Geometric Data object
    """
    with open(json_path, 'r', encoding='utf-8') as f:
        data = json.load(f)

    nodes = data['Nodes']
    edges = data['Edges']

    if len(nodes) == 0:
        return None

    # Extract node features
    node_features = []
    for node in nodes:
        embedding = node.get('DecompileEmbedding', None)
        if embedding is None or len(embedding) == 0:
            embedding = [0.0] * 768
        node_features.append(embedding)

    # Convert to tensor
    x = torch.tensor(node_features, dtype=torch.float)

    # Extract edges
    if len(edges) > 0:
        edge_list = [[edge['from'], edge['to']] for edge in edges]
        edge_index = torch.tensor(edge_list, dtype=torch.long).t().contiguous()
    else:
        edge_index = torch.empty((2, 0), dtype=torch.long)

    # Create Data object (no label for inference)
    graph = Data(x=x, edge_index=edge_index)

    return graph

def classify_binary(binary_path, model, label_mapping, device):
    """
    Classify a binary file

    Args:
        binary_path: Path to binary file
        model: Trained model
        label_mapping: Label mapping dict
        device: Device to use

    Returns:
        dict: Classification result
    """
    binary_path = Path(binary_path)

    # Create temporary directory for feature extraction
    with tempfile.TemporaryDirectory() as temp_dir:
        temp_dir = Path(temp_dir)

        # Extract features
        print(f"\nExtracting features from: {binary_path.name}")
        print("-" * 60)

        features = extract_features_from_binary(
            binary_path=binary_path,
            apt_group="Unknown",  # We don't know the group yet
            output_dir=temp_dir
        )

        if features is None:
            print("Error: Feature extraction failed!")
            return None

        # Load graph
        json_path = temp_dir / f"{binary_path.stem}.json"
        graph = load_graph_from_json(json_path)

        if graph is None:
            print("Error: Failed to load graph!")
            return None

    # Prepare graph for model
    graph = graph.to(device)

    # Add batch index (single graph)
    batch = torch.zeros(graph.x.size(0), dtype=torch.long, device=device)

    # Run inference
    model.eval()
    with torch.no_grad():
        logits = model(graph.x, graph.edge_index, batch)
        probabilities = torch.softmax(logits, dim=1)
        pred_label = logits.argmax(dim=1).item()
        pred_prob = probabilities[0, pred_label].item()

    # Get all class probabilities
    id_to_label = {v: k for k, v in label_mapping.items()}
    all_probs = {}
    for i in range(len(label_mapping)):
        all_probs[id_to_label[i]] = probabilities[0, i].item()

    # Sort by probability
    sorted_probs = sorted(all_probs.items(), key=lambda x: x[1], reverse=True)

    # Create result
    result = {
        'binary': binary_path.name,
        'predicted_group': id_to_label[pred_label],
        'confidence': pred_prob,
        'all_probabilities': all_probs,
        'top_3_predictions': sorted_probs[:3]
    }

    return result

# =============================================================================
# Main
# =============================================================================

def main():
    """Main function"""

    if len(sys.argv) < 2:
        print("Usage: python classify_binary.py <binary_path>")
        print("Example: python classify_binary.py /path/to/malware.exe")
        sys.exit(1)

    binary_path = sys.argv[1]

    if not Path(binary_path).exists():
        print(f"Error: Binary not found: {binary_path}")
        sys.exit(1)

    print("=" * 80)
    print("APT Group Classification")
    print("=" * 80)
    print(f"Binary: {binary_path}")
    print(f"Device: {DEVICE}")
    print("=" * 80)

    # Initialize PyGhidra and embedding model
    print("\nInitializing PyGhidra and embedding model...")
    initialize_pyghidra()
    initialize_embedding_model()

    # Load label mapping
    print("\nLoading label mapping...")
    if not LABEL_MAPPING_PATH.exists():
        print(f"Error: Label mapping not found at {LABEL_MAPPING_PATH}")
        print("Please train the model first using train.py")
        sys.exit(1)

    label_mapping = load_label_mapping(LABEL_MAPPING_PATH)
    num_classes = len(label_mapping)
    print(f"  Number of classes: {num_classes}")

    # Load model
    print("\nLoading model...")
    if not BEST_MODEL_PATH.exists():
        print(f"Error: Model not found at {BEST_MODEL_PATH}")
        print("Please train the model first using train.py")
        sys.exit(1)

    checkpoint = torch.load(BEST_MODEL_PATH, map_location=DEVICE)

    model = GATv2APTClassifier(
        input_dim=768,
        hidden_dim=128,
        num_classes=num_classes,
        dropout=0.3
    ).to(DEVICE)

    model.load_state_dict(checkpoint['model_state_dict'])
    print(f"  ✓ Loaded model from epoch {checkpoint['epoch']}")

    # Classify binary
    print("\n" + "=" * 80)
    print("Classification")
    print("=" * 80)

    result = classify_binary(binary_path, model, label_mapping, DEVICE)

    if result is None:
        print("\nClassification failed!")
        sys.exit(1)

    # Print results
    print("\n" + "=" * 80)
    print("Results")
    print("=" * 80)
    print(f"\nBinary: {result['binary']}")
    print(f"Predicted APT Group: {result['predicted_group']}")
    print(f"Confidence: {result['confidence']:.4f} ({result['confidence'] * 100:.2f}%)")

    print(f"\nTop 3 Predictions:")
    print("-" * 60)
    for i, (group, prob) in enumerate(result['top_3_predictions'], 1):
        print(f"  {i}. {group:30s}: {prob:.4f} ({prob * 100:.2f}%)")

    print("\n" + "=" * 80)

    # Save result to JSON
    output_file = Path(binary_path).parent / f"{Path(binary_path).stem}_classification.json"
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(result, f, indent=2, ensure_ascii=False)

    print(f"✓ Classification result saved to: {output_file}")
    print("=" * 80)

if __name__ == "__main__":
    main()
